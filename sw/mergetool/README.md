# Загрузка прошики MCU в файл конфигурации ПЛИС

Данный алгоритм создаёт новый файл конфигурации ПЛИС "out_fpga".fs заменяя данные блоков памяти BSRAM в файле конфигурации ПЛИС "in_fpga".fs на данные актуального проекта MCU "in_mcu".bin, принимая во внимание фактическое расположение блоков BSRAM после синтеза проекта ПЛИС согласно файлу "in_bsram_location".posp.

Выполнение данного скрпита вызывается следующей строкой с указаннием входных и выходных файлов в качестве аргументов: <br>
<code>mergetool.exe "in_fpga".fs "in_bsram_location".posp "in_mcu".bin "out_fpga".fs</code>

Описание разлелено на 2 части:
+ Функциональное описание алгоритма работы;
+ Дополнительная информация;
+ Описание кода алгоритма.

## Функциональное описание алгоритма работы
ПЛИС *GW1NR-9* содержит внутри 26 блоков памяти *BSRAM(Block Static Random Access Memory)*, которые могут конфигурироваться из встроенной флеш-памяти автоматически при включении питания ПЛИС. Конфигурирование флеш памяти осуществляется специальной утилитой производителя *GOWIN PROGRAMMER*, данные для конфигурирования эта утилита берёт из файла конфигурации ПЛИС \*.fs.

Блоки BSRAM комбинируются вместе для достижения необходимого объема и используются для организации памяти инструкций/данных программного ядра микропроцессора внутри ПЛИС. Чтобы, например, загрузить набор инструкций в такие блоки необходимо создать дополнительный файл инициализации памяти со списком 32 битных инструкций, и затем использовать этот файл при конфигурировании памяти инструкций внутри среды разработки ПЛИС *GOWIN IDE* с помощью встроенного  редактора IP-ядер. Такой процесс загрузки инструкций для программного микропроцессора требует множетсва манипуляций и затрачивает колоссальное время разработчика.

Для ускорения процедуры разработки проекта микропроцессора на *С/С++*, а именно процедуры загрузки инструкций в память ПЛИС, используется алгоритм подмены данных в блоках памяти BSRAM непосредственно в файле конфигурации ПЛИС согласно следующему алгоритму. 
### 1. Получаем данные файла "in_mcu".bin, содержащего набор инструкций в машинном коде
Данный файл является результатом компиляции *С/С++* проекта микропроцессора в среде *GOWIN GMD*(он же *Eclipse*). Пример интерпретации данных файла с набором инструкций:

&emsp;&ensp;0: **<ins>00500113</ins>**&emsp;addi x2, x0, 5 &emsp; //x2 = 5
<br>&emsp;&ensp;1: **00C00193**&emsp;addi x3, x0, 12&emsp;//x3 = 12
<br>&emsp;.. &nbsp;: &emsp;&emsp;...&emsp;&emsp;&emsp;&emsp;&emsp; ...&emsp;&emsp;&emsp;&emsp; //Набор инструкций risc-v
<br>&emsp;31: **FF718393**&emsp;addi x7, x3, -9&emsp; //x7 = 12  -  9   = 3
<br>&emsp;32: **0023E233**&emsp;or   x4, x7, x2&emsp;&emsp;//x4 = 3  OR  5   = 7			

### 2. Распределить байты инструкций между массивами, соответствующими блокам BSRAM
Для памяти объёмом 8 кБайт, состощим из 4 блоков BSRAM, инструкция машинного кода (4 байта) раскладывается по одному байту в 4 блока BSRAM, следующая инструкция также. Наглядно распределение инструкций показано в таблицах с 1-1 по 1-4.

<div align="right">Таблица 1-1. Представление блока BSRAM №1 с распределёнными инструкциями машинного кода</div>

<div align="center">

|Адр.\Байт|31 |...| 3 | 2 | 1    | 0           |
|:-------:|:-:|:-:|:-:|:-:|:----:|:-----------:|
|    00   |93 |...|...|...|**93**|<ins>13</ins>|
|    01   |...|...|...|...|...   |33           |
|   ...   |...|...|...|...|...   |...          |
|    3F   |...|...|...|...|...   |...          |

</div>

<div align="right">Таблица 1-2. Представление блока BSRAM №2 с распределёнными инструкциями машинного кода</div>

<div align="center">

|Адр.\Байт|31 |...| 3 | 2 | 1 | 0           |
|:-------:|:-:|:-:|:-:|:-:|:-:|:-----------:|
|    00   |83 |...|...|...|01 |<ins>01</ins>|
|    01   |...|...|...|...|...|E2           |
|   ...   |...|...|...|...|.. |...          |
|    3F   |...|...|...|...|...|...          |

</div>

<div align="right">Таблица 1-3. Представление блока BSRAM №3 с распределёнными инструкциями машинного кода</div>

<div align="center">

|Адр.\Байт|31 |...| 3 | 2 | 1 | 0           |
|:-------:|:-:|:-:|:-:|:-:|:-:|:-----------:|
|    00   |71 |...|...|...|C0 |<ins>50</ins>|
|    01   |...|...|...|...|...|23           |
|   ...   |...|...|...|...|.. |...          |
|    3F   |...|...|...|...|...|...          |

</div>

<div align="right">Таблица 1-4. Представление блока BSRAM №4 с распределёнными инструкциями машинного кода</div>

<div align="center">

|Адр.\Байт|31 |...| 3 | 2 | 1 | 0           |
|:-------:|:-:|:-:|:-:|:-:|:-:|:-----------:|
|    00   |FF |...|...|...|00 |<ins>00</ins>|
|    01   |...|...|...|...|...|00           |
|   ...   |...|...|...|...|.. |...          |
|    3F   |...|...|...|...|...|...          |

</div>
    
### 3. Преобразовать байтовые массивы в строковые согласно разметке строчек и проходов \*.fs файла
Один блок BSRAM в файле .fs имеет 256 строк. При преобразовании данных в строковые массивы, для последующей записи в файл, необходимо совершить 4 прохода на каждую строку. За один проход строки производится запись 2 байт (16 бит) данных в определённые позиции строки, запись следующих данных на этом проходе производится во все оставшиеся строки. После чего начинается новый проход записи данных по тем же 256 строкам, но в новые позиции в строках. Данные для записи берутся из подготовленных в предыдущем пункте массивов, и начиная с нулевого элемента массива записываются по порядку в строки начиная с конца блока (начиная с 256 строки). Процедура повторяется для всех блоков BSRAM, на выходе должно получиться четыре строковых массива, каждый из которых содержит 256 строк с новыми данными.

В таблице 2 показаны необходимые позиции битов для записи в строку на каждом проходе. В таблице также продемонстрировано как байты из блока памяти BSRAM таблицы 1-1 преобразуются в набор битов и распределяются в нужные позиции:
- Байт <ins>13</ins> преобразован в <ins>00010011</ins> и записан в позиции 61, 51, 43, 35, 26, 17, 9, 0.
- Байт **93** преобразован в **10010011** и записан в позиции 138, 129, 121, 112, 103, 95, 86, 77.


<div align="right">Таблица 2. Номера позиций записываемых битов при каждом проходе. Пример распределения битов в позиции строки для блока BSRAM №1</div>

<div>

|Проход\Бит.|15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
|:---------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|Проход 1   |138|129|121|112|103|95 |86 |77 |61 |51 |43 |35 |26 |17 | 9 | 0 |
|data/BIN   |**1**|**0**|**0**|**1**|**0**|**0**|**1**|**1**|<ins>0</ins>|<ins>0</ins>|<ins>0</ins>|<ins>1</ins>|<ins>0</ins>|<ins>0</ins>|<ins>1</ins>|<ins>1</ins>|
|Проход 2   |139|130|122|113|104|96 |88 |78 |62 |52 |44 |36 |27 |18 |10 | 1 |
|data/BIN   | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X |
|Проход 3   |144|135|127|118|110|101|92 |84 |66 |58 |49 |40 |32 |23 |14 | 6 |
|data/BIN   | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X |
|Проход 4   |145|136|128|119|111|102|93 |85 |68 |59 |50 |41 |33 |24 |16 | 7 |
|data/BIN   | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X |

</div>

При записи данных в строковые массивы необходимо учитывать своеобразный порядок смены строк внутри одного/каждого прохода. Далее показан алгормит переключения между строками, в котором в квадратных скобках указывается [номер строки], а каждое последующе приращение строки представляется числом со знаком перед ним +/-.

&emsp;**Проход №1**<br>
&emsp;&emsp;&emsp; &nbsp; [255] >> -128 >> [127] >> +64 >> [191] >> -128 >> [63] >> +191 >> <br>
&emsp;&emsp; >> [254] >> -128 >> [126] >> +64 >> [190] >> -128 >> [62] >> +191 >> <br>
&emsp;&emsp; >> [........] >> -128 >> [.......] >> +64 >> [.......] >> -128 >> [.....] >> +191 >><br>
&emsp;&emsp; >> [192] >> -128 >> [ 64 ] >> +64 >> [128] >> -128 >> [ 0 ]<br>
&emsp;**Проход №2** - Повторный проход тех же строк с записью данных в новые позиции битов<br>
&emsp;**Проход №3** - Повторный проход тех же строк с записью данных в новые позиции битов<br>
&emsp;**Проход №4** - Повторный проход тех же строк с записью данных в новые позиции битов<br>
   
### 4. Включить надстройку генерации Post-Place File в редакторе *GOWIN IDE*, а также отключить формирование контрольной суммы CRC
В данном проекте ПЛИС используется 4 блока BSRAM и при синтезе проекта редактор использует реальные блоки памяти в произвольном порядке, всего в микросхеме *GW1NR-9* доступно 26 таких блоков памяти. Для определения их реального расположения, в редакторе *GOWIN IDE* включаем функцию:<br> <code>Project -> Configuration -> Place & Routine -> General -> Generate Post-Place File -> True</code>

На данный момент алгоритм не реализует расчёт и подмену контрольной суммы в строках с инициализацией данных блоков памяти BSRAM при записи в \*.fs файл, поэтому формирование CRC должно быть отключено в редакторе *GOWIN IDE*:<br>
<code>Project -> Configuration -> BitStream -> Enable CRC Check -> Снять галочку</code>

### 5. Получить данные расположения блоков памяти после синтеза проекта ПЛИС из файла "in_bsram_location".posp
После синтеза проекта ПЛИС будет появляться файл с расширением \*.posp, в котором показано какие конкретно блоки памяти BSRAM использовались при синтезе проекта ПЛИС, а также их связь с программными представлениями (sp_inst_X). Надпись <code>imem</code> указывает на то, что блок памяти BSRAM используется как память инструкций. Получаем данные из файла "in_bsram_location".posp  

    imem/sp_inst_2 PLACE_BSRAM_R10[5]
    imem/sp_inst_1 PLACE_BSRAM_R10[4] 
    imem/sp_inst_0 PLACE_BSRAM_R28[4]
    imem/sp_inst_3 PLACE_BSRAM_R28[5]

### 6. Определить расположение используемых блоков памяти в разметке файла \*.fs, согласно таблице 3.
Данные блоков памяти в этом файле расположены в двух горизонатльных зонах R10 (11 блоков BSRAM) и R28 (15 блоков BSRAM). Ниже приведена таблица 3 расположения блоков памяти в файле *.fs<br>
Блоки памяти зоны **R10** расположены в **строках 744-999**.<br>
Блоки памяти зоны **R28** расположены в **строках 1000-1255**

<div align="right">Таблица 3. Разметка ячеек памяти BSRAM в файле *.fs</div>

<div>

|Зона\Поз.| 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
|:-------:|:--:|:--:|:--:|:--:|:--:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| **R10** | X  |[10]|[9] |[8] |[7] | X | X |[6]|[5]|[4]|[3]|[2]|[1]|[0]| X |
| **R28** |[14]|[13]|[12]|[11]|[10]|[9]|[8]|[7]|[6]|[5]|[4]|[3]|[2]|[1]|[0]|

</div>

### 7. Определить стартовые адреса в строке файла \*.fs для каждого используемого блока BSRAM
Все строки с инициализацией данных блоков памяти BSRAM в файле \*.fs имеют одинаковую структуру, которая показана в таблице 4. Нулевой символ строки принимается с начала строки(слева). Структура строки содержит секции обозначенные заглавными латинскими буквами, для каждой секции показана стартовая позиция символа и конечная позиция символа, длина секции, а также значения данных для зон R28 и R10. Для поиска позиций записи данных в строке сначала нужно найти номер используемого блока памяти BSRAM, например **R10[5]**, значение в столбце "Начало" и "Конец" будут соответствовать тому диапазону символов, который необходимо заменить на новые данные, в этом примере диапазон **[1516:1670]**. 

<div align="right">Таблица 4. Разметка одной строки с инициализацей<br> блоков памяти BSRAM в файле *.fs</div>

<div>

|Секция |Начало|Конец |Длина|R28     |R10     |Примечание                 |
|:-----:|:----:|:----:|:---:|:------:|:------:|---------------------------|
|  A    |  0   |   3  |   4 |  1111  |  1111  |Стартовый символ F         |
|  B    |  4   |  75  |  72 |72{0}\* |72{0}\* |До первого блока BSRAM     |
|  C14  |  76  | 230  | 155 |**[14]**|72{0}\* |Блок памяти BSRAM          |
|  D14  |  231 | 255  |  25 |  25{0} |  25{0} |Между блоками BSRAM        |
|  C13  |  256 | 410  | 155 |**[13]**|**[10]**|Блок памяти BSRAM          |
|  D13  |  411 | 435  |  25 |  25{0} |  25{0} |Между блоками BSRAM        |
|  C12  |  436 | 590  | 155 |**[12]**|**[9]** |Блок памяти BSRAM          |
|  D12  |  591 | 615  |  25 |  25{0} |  25{0} |Между блоками BSRAM        |
|  C11  |  616 | 770  | 155 |**[11]**|**[8]** |Блок памяти BSRAM          |
|  D11  |  771 | 795  |  25 |  25{0} |  25{0} |Между блоками BSRAM        |
|  C10  |  796 | 950  | 155 |**[10]**|**[7]** |Блок памяти BSRAM          |
|  D10  |  951 | 975  |  25 |  25{0} |  25{0} |Между блоками BSRAM        |
|  C9   |  976 |1130  | 155 |**[9]** |72{0}\* |Блок памяти BSRAM          |
|  D9   | 1131 |1155  |  25 |  25{0} |  25{0} |Между блоками BSRAM        |
|  C8   | 1156 |1310  | 155 |**[8]** |72{0}\* |Блок памяти BSRAM          |
|  D8   | 1311 |1335  |  25 |  25{0} |  25{0} |Между блоками BSRAM        |
|  C7   | 1336 |1490  | 155 |**[7]** |**[6]** |Блок памяти BSRAM          |
|  D7   | 1491 |1515  |  25 |  25{0} |  25{0} |Между блоками BSRAM        |
|  C6   | 1516 |1670  | 155 |**[6]** |**[5]** |Блок памяти BSRAM          |
|  D6   | 1671 |1695  |  25 |  25{0} |  25{0} |Между блоками BSRAM        |
|  C5   | 1696 |1850  | 155 |**[5]** |**[4]** |Блок памяти BSRAM          |
|  D5   | 1851 |1875  |  25 |  25{0} |  25{0} |Между блоками BSRAM        |
|  C4   | 1876 |2030  | 155 |**[4]** |**[3]** |Блок памяти BSRAM          |
|  D4   | 2031 |2055  |  25 |  25{0} |  25{0} |Между блоками BSRAM        |
|  C3   | 2056 |2210  | 155 |**[3]** |**[2]** |Блок памяти BSRAM          |
|  D3   | 2211 |2235  |  25 |  25{0} |  25{0} |Между блоками BSRAM        |
|  C2   | 2236 |2390  | 155 |**[2]** |**[1]** |Блок памяти BSRAM          |
|  D2   | 2391 |2415  |  25 |  25{0} |  25{0} |Между блоками BSRAM        |
|  C1   | 2416 |2570  | 155 |**[1]** |**[0]** |Блок памяти BSRAM          |
|  D1   | 2571 |2595  |  25 |  25{0} |  25{0} |Между блоками BSRAM        |
|  C0   | 2596 |2750  | 155 |**[0]** |72{0}\* |Блок памяти BSRAM          |
|  E    | 2751 |2839  |  89 |89{0}\* |89{0}\* |Между последним BSRAM и CRC|
|*F\*\**|*2840*|*2855*| *16*| *CRC16*| *CRC16*|*Контрольная сумма CRC16*  |
|  G    | 2856 |2903  |   4 |  48{1} |  48{1} |Конечные символы 12{F}     |

</div>

\* В секторе может находится конфигурационная информация, поэтому не рекомендуется изменять данные.<br>
\*\* Контрольная сумма *CRC16* может быть отключена в редакторе *GOWIN IDE*, в таком случае последний сектор G смещается на 16 символов влево.

### 8. Получить данные входного файла конфигурации ПЛИС "in_fpga".fs, заменить необходимые данные в используемых блоках памяти BSRAM не затрагивая других данных. Полученный результат сохранить в новый файл "out_fpga".fs

Последовательность действий для записи в файл "out_fpga".fs описана в списке ниже, а также продемонстрирована в таблице 5:
1. Берём строковые массивы подготовленные для записи согласно разметке файла \*.fs, полученные в пункте 3 настоящей инструкции;
2. Сопоставляем программные представления блоков памяти BSRAM с реально используемыми блоками внутри микросхемы согласно пункту 6;
3. Находим изменяемый диапазон строк и диапазон столбцов для каждого блока памяти BSRAM согласно пунктам 6 (для строк) и 7 (для столбцов);
4. Получаем данные входного файла конфигурации ПЛИС "in_fpga".fs;
5. Заменяем необходмые данные по найденым адресам, не затрагивая прочих данных;
6. Полученный результат сохраняем в новый файл "out_fpga".fs

<div align="right">Таблица 5. Сопоставление данных текущего примера для организации записи в файл *.fs</div>

<div align="center">

|Прогр. BSRAM|Факт. BSRAM|Диапазон строк|Диапазон столбцов|
|:----------:|:---------:|:------------:|:---------------:|
|sp_inst_0   |**R28[4]** |[1000:1255]   |[1876:2030]      |
|sp_inst_1   |**R10[4]** |[744:999]     |[1696:1850]      |
|sp_inst_2   |**R10[5]** |[744:999]     |[1516:1670]      |
|sp_inst_3   |**R28[5]** |[1000:1255]   |[1696:1850]      |

</div>

## Дополнительная информация

<div align="right">Таблица 6. Сравнение конфигураций позиций записываемых битов блока BSRAM(в фале *.fs) для шин 32 бит и 36 бит</div>

|<ins>36&nbsp;бит</ins>    |17 |16 |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
|:------------------------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|Проход&nbsp;1             |147|138|129|121|112|103|95 |86 |77 |69 |61 |51 |43 |35 |26 |17 | 9 | 0 |
|Проход&nbsp;2             |148|139|130|122|113|104|96 |88 |78 |70 |62 |52 |44 |36 |27 |18 |10 | 1 |
|Проход&nbsp;3             |152|144|135|127|118|110|101|92 |84 |75 |66 |58 |49 |40 |32 |23 |14 | 6 |
|Проход&nbsp;4             |154|145|136|128|119|111|102|93 |85 |76 |68 |59 |50 |41 |33 |24 |16 | 7 |
|                          |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|**<ins>32&nbsp;бит</ins>**|   |15 |14 |13 |12 |11 |10 |9  | 8 |   | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
|Проход&nbsp;1             |   |138|129|121|112|103|95 |86 |77 |   |61 |51 |43 |35 |26 |17 | 9 | 0 |
|Проход&nbsp;2             |   |139|130|122|113|104|96 |88 |78 |   |62 |52 |44 |36 |27 |18 |10 | 1 |
|Проход&nbsp;3             |   |144|135|127|118|110|101|92 |84 |   |66 |58 |49 |40 |32 |23 |14 | 6 |
|Проход&nbsp;4             |   |145|136|128|119|111|102|93 |85 |   |68 |59 |50 |41 |33 |24 |16 | 7 |

## Описание кода алгоритма

### Переменые для работы 
В начале алгоритма инициализируются переменные для работы найденые чисто **империческим** путем
```python
#0.1 Соотносим блоки BSRAM и начальные позиции записи в строке *.fs
              #    0    1    2    3    4    5    6    7   8   9  10
bsram_stPosR10 = [2570,2390,2210,2030,1850,1670,1490,950,770,590,410]
              #    0    1    2    3    4    5    6    7    8    9   10  11  12  13  14
bsram_stPosR28 = [2750,2570,2390,2210,2030,1850,1670,1490,1310,1130,950,770,590,410,230]
bsram_stPos = [bsram_stPosR10, bsram_stPosR28]
bsram_stStr = [999-1         , 1255-1        ]
#0.2 Позиции изменяемых битов при каждом новом проходе строки BSRAM файла *.fs
bit_loc_pas0 = [138,129,121,112,103,95,86,77,61,51,43,35,26,17,9,0]                                 #Позиции битов для первого прохода
bit_loc_pas1 = [139,130,122,113,104,96,88,78,62,52,44,36,27,18,10,1]                                #Позиции битов для второго прохода
bit_loc_pas2 = [144,135,127,118,110,101,92,84,66,58,49,40,32,23,14,6]                               #Позиции битов для третьего прохода
bit_loc_pas3 = [145,136,128,119,111,102,93,85,68,59,50,41,33,24,16,7]                               #Позиции битов для четвертого прохода
bit_loc_pas = [bit_loc_pas0, bit_loc_pas1, bit_loc_pas2, bit_loc_pas3]                              #Собираем массивы в один лист для дальнейшей работы с ним
```
### Дейсвие первое **Открытие файла с инструкциями**
```python
with open("fw/Debug/riscv.bin", "rb") as file:
    binary_data = file.read()
```
### Дейсвие второе **Преобразование машинного кода**
```python
bsram = [[],[],[],[]]
i = 0
for byte in binary_data:                                                                            #Раскидываем байты файла *.bin между 4 строками для блоков BSRAM
    bsram[i].append(byte)
    if (i == 3):
        i = 0
    else: i = i + 1   
i = 0
j = 0
for i in range(4):
    for j in range(len(bsram[i]), 2048):                                                            #Дополняем строки до полного объёма блоков BSRAM
        bsram[i].append(0)
```
### Дейсвие третье **Работа с файлом .posp**
В файле с расширением .posp указаны какие блоки памяти используются
```
imem/sp_inst_2 PLACE_BSRAM_R10[5]   
imem/sp_inst_1 PLACE_BSRAM_R10[4]  
imem/sp_inst_0 PLACE_BSRAM_R28[4]  
imem/sp_inst_3 PLACE_BSRAM_R28[5]  
```
нам необходимо достать строки в которых есть ключевое слово **imem**
для этого будем использовать следующий алгоритм:
```python
with open("hw/impl/pnr/riscv.posp", "r") as file:                                                   #Открываем *.posp
    text_data = file.read()
imem_list = re.findall("imem.*", text_data)    
```
Строка:
```python
imem_list = re.findall("imem.*", text_data) 
```
ищет все строки которые содержат слово **imem**, затем знак **"."** указывает на то что после может быть любой символ, затем знак **"*"** указывает на любое количество символов.   
Далее необходимо достать номер **"sp_inst_"**, указатель блока памяти **"R10"** или  **"R28"**, а так же индекс блока, например **"[5]"**. Данное действие выполняет алгоритм:
```python
for string in imem_list:
    block0 = re.findall('([0-9]+ )', string)                                                        #Одна или несколько цифр перед пробелом это номер представления BSRAM
    block1 = re.findall('(R[0-9]+)', string)                                                        #Цифра вместе с буквой R определяет зону расположения блока BSRAM
    block2 = re.findall(r'(\[[0-9]+\])', string)                                                    #Цифра в квадратных скобках показывает расположение блока BSRAM в строке
    bsram_loc.append([block0[0], block1[0], block2[0]])
```  
после выполнения кода получим лист **bsram_loc** в котором находятся данные с номером sp_inst, указателем памяти и индексом, например **[['2 ', 'R10', '[5]']]**, далее для удобства работы необходимо изменить данные **"R10"** или **"R28"** на 0 для R10 и 1 для R28, с помошью кода:
```python
for i , string in enumerate(bsram_loc):                                                             #Удаляем все символы из строк и преобразовываем строки в числа
    for j, element in enumerate(string):
        if (j == 1):                                                                                #Если элемент 1, то происходит замена, на:                                                                           
            match element:
                case 'R10': bsram_loc[i][j] = 0                                                     #Заменяем R10 на 0
                case 'R28': bsram_loc[i][j] = 1                                                     #Заменяем R28 на 1
                case _: print(element,'Ошибка! Сектор BSRAM не существует!')                        #Несуществующий сектор BSRAM
        else: bsram_loc[i][j] = int(re.sub('[^0-9]', '', element))
```  
Данный код проходится по всем первым индексам и в зависимости от значения меняет на **0** или **1**  
Далее для удобной работы с листом его необходимо отсортировать по номеру **sp_inst**
с помощью функции:
```python
bsram_loc.sort() 
```  
### Дейсвие четвертое **Работа с файлом .fs**
Необходимо открыть файл конфигурации ПЛИС с расширением **.fs**
```python
with open("hw/impl/pnr/ao_0.fs", "r") as file:                                                      #Открываем *.fs и выгрузим все строки отдельно в список
    conf_data = file.readlines()
```
каждая строка условно поделена на 3 блока, первая и третья часть строки не несет в себе полезной информации, нам нужна только центральная часть. Для удобства работы необходимо сохранить первую и третью часть строки, а вторую заполнить **0**. С помощью кода:
```python
for bsram_num in range(4):                                                                          #Сначала определим какой блок BSRAM и стартовый адрес записи
    bsram_zone = bsram_loc[bsram_num][1]                                                            #Зона в которой располагается BSRAM: 0 - R10; 1 - R28;       
    bsram_no   = bsram_loc[bsram_num][2]                                                            #Номер блока BSRAM в который записываем
    base_str   = bsram_stStr[bsram_zone]                                                            #Базовый номер строки для начала записи
    base_pos = bsram_stPos[bsram_zone][bsram_no]                                                    #Базовая позиция символа для начала записи
    shift_str = 0                                                                                   #Смещение базового номера строки
    bsram_str = ['0'] * 155                                                                         #Инициализируем список символов строки BSRAM файла *.fs нулевыми символами
    for i in range(256):                                                                            #Обнуляем все данные в текущем блоке BSRAM
        current_str = base_str - i                                                                  #Проходим по всем строкам
        first_part_of_str = conf_data[current_str][:base_pos-154]                                   #Оставляем без измененной первую часть строки
        second_part_of_str = ''.join(bsram_str)                                                     #Изменяем вторую часть строки на "0" для дальнейшей обработки
        third_part_of_str = conf_data[current_str][base_pos+1:]                                     #Оставляем без измененной третью часть строки
        conf_data[current_str] = first_part_of_str + second_part_of_str + third_part_of_str         #Собираем все части строк в одну
```
Коментарии указывают на фунции каждой строки  
Далее необходимо сформировать строки для записи на основе массива BSRAM который мы получили во втором действии, ниже показан код который сначала формирует строки
,а потом перезаписывает во вторую часть памяти, так же в конце кода вычесляется **shift_str** для следущего прохода  
```python
bit_list0 = []
bit_list1 = []
bit_list  = [] 
for i, byte in enumerate(bsram[bsram_num]):                                                         #Перебераем файл .bin для создания файла .fs
        each2bytes = i%2                                                                            #Каждые два байта
        if (each2bytes):                                                                            #Создаём список с битами 2ух байт для записи в строку BSRAM
            bit_list1 = [1 if x=='1' else 0 for x in "{:08b}".format(byte)]                         #Упрощеная запись условия обернутого в цикл
            bit_list = bit_list1 + bit_list0                                                        #Собираем два байта в один лист
        else:    
            bit_list0 = [1 if x=='1' else 0 for x in "{:08b}".format(byte)]                         #Упрощеная запись условия обернутого в цикл
        if (each2bytes):                                                                            #Расставляем битики данных в одной строке BSRAM
            j = i//2                                                                                #Счётчик пар байтов
            p = j//256                                                                              #Номер прохода (всего 4 прохода)
            if((j % 256) == 0): shift_str = 0                                                       #Осуществляем сброс смещения строки каждые 256 значений
            current_str = base_str + shift_str                                                      #Добавляем смещение текущей строки
            bsram_str = list(conf_data[current_str][base_pos-154:base_pos+1])                       #Берём за основу строку из файла и заменяем в ней нужные символы
            for k, bit in enumerate(bit_list):                                                      #Перебераем массив bit_list                                                                                                             
                bsram_str[154-bit_loc_pas[p][k]] = str(bit)                                         #Создаем строку bsram_str из bit_list                         
            #Записываем битики в строку BSRAM выгруженную из файла *.fs
            first_part_of_str = conf_data[current_str][:base_pos-154]                               #Оставляем без измененной первую часть строки
            second_part_of_str = ''.join(bsram_str)                                                 #Изменяем вторую часть строки (только в ней хранятся полезные данные)
            third_part_of_str = conf_data[current_str][base_pos+1:]                                 #Оставляем без измененной третью часть строки
            conf_data[current_str] = first_part_of_str + second_part_of_str + third_part_of_str     #Собираем 3 части строки в одну
            match ((j % 256) % 4):                                                                  #Определяем номер строки для следующей записи (всего 4 прохода)   
                case 0: shift_str = shift_str - 128                                                 #Начальная позиция для первого прохода
                case 1: shift_str = shift_str + 64                                                  #Начальная позиция для второго прохода
                case 2: shift_str = shift_str - 128                                                 #Начальная позиция для третьего прохода
                case 3: shift_str = shift_str + 191                                                 #Начальная позиция для четвертого прохода
```
### Действие пятое Собираем новый файл .fs
```python
with open("hw/impl/pnr/riscv.fs", "w") as file:                                                     #Запись данных в новый файл riscv.fs
    file.writelines(conf_data)
```
